---
title: "DIとDIPとIoCとデザインパターンと"
emoji: "🌏"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["設計", "デザインパターン", "DI", "DIP", "IoC"]
published: false
---

# 概要
本記事では、設計やデザインパターンで頻出の以下の単語の関係性に関する自分の解釈を述べます。

- [依存性の注入 (Dependency Injection: DI)](https://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E6%80%A7%E3%81%AE%E6%B3%A8%E5%85%A5)
- [SOLID原則](https://ja.wikipedia.org/wiki/SOLID)
    - [依存性逆転の法則 (Dependency Inversion Principle: DIP)](https://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E6%80%A7%E9%80%86%E8%BB%A2%E3%81%AE%E5%8E%9F%E5%89%87)
    - [開放/閉鎖原則 (Open/Closed Principle: OCP)](https://ja.wikipedia.org/wiki/%E9%96%8B%E6%94%BE/%E9%96%89%E9%8E%96%E5%8E%9F%E5%89%87)
- [制御の逆転 (Inversion of Control: IoC)](https://ja.wikipedia.org/wiki/%E5%88%B6%E5%BE%A1%E3%81%AE%E5%8F%8D%E8%BB%A2)
- [デザインパターン](https://ja.wikipedia.org/wiki/%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3_(%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2))
    - [ストラテジーパターン](https://ja.wikipedia.org/wiki/Strategy_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3)
    - [デコレーターパターン](https://ja.wikipedia.org/wiki/Decorator_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3)
    - etc...
- [デリゲート（委譲）](https://ja.wikipedia.org/wiki/%E5%A7%94%E8%AD%B2)
- [合成](https://en.wikipedia.org/wiki/Object_composition)

このあたりの単語を知ったときに、「他のあの概念と似てるけど関連性や違いは？」といった疑問が自分は頻繁に生じたので、そういった疑問の解消の手助けになれば幸いです。したがって、各単語の意味はなんとなくわかる程度の知識を前提とします。また本記事におけるデザインパターンとは「オブジェクト指向における再利用のためのデザインパターン」（通称GoF本）という本で定義されたものを指します。

# 単語の関係性
以下の節に分けてそれぞれの関連を説明します。
- DIとDIP
- DIとIoCとデザインパターン
- デリゲートと合成とデザインパターンとDI
- DIPとOCPとデザインパターン


### DIとDIP
DIPを実現させる方法の一つとしてDIがあります。**依存性の注入（DI）** とは、モジュールAがモジュールBを呼び出している（**依存**している）とき、Aの引数やコンストラクタを介してBを外部からAに渡す（**注入**する）ことを指します。このときBを受け取るAの引数の型をinterfaceやabstract classなどの抽象型として定義し[^1]、その抽象型を実装したBを注入すれば、AがBに直接依存することを防ぐことができます。つまり、Aは実装の詳細を持つBに依存せず、Bのインターフェースにのみ依存しているということです。また、BはAが定義したBのインターフェースを実装する必要があり、もともとAがBに依存していた関係がDIにより逆転していると言えます。これはまさに、上位モジュールと下位モジュールはともに抽象に依存するべきで、抽象は詳細に依存してはならないという**依存性逆転の原則**を満たしています。まとめると、DIをする際にその依存対象を抽象として扱うことで、DIPを満たすと言えます。

![](/images/di-dip-ioc-design-patterns/di.png =500x)

:::details コード例
- DI前のコード
    ```java
    class A {
        private B b;
        public A(B b) {
            this.b = b;
        }
        public void doSomething() {
            b.doSomething();
        }
    }

    class B {
        public void doSomething() {
            // do something
        }
    }

    class Main {
        public static void main(String[] args) {
            B b = new B();
            A a = new A(b);
            a.doSomething();
        }
    }
    ```

- DIによりDIPを満たすコード
    ```java
    class A {
        private IB b;
        public A(IB b) {
            this.b = b;
        }
        public void doSomething() {
            b.doSomething();
        }
    }

    interface IB {
        public void doSomething();
    }

    class B implements IB {
        public void doSomething() {
            // do something
        }
    }

    class Main {
        public static void main(String[] args) {
            B b = new B();
            A a = new A(b);
            a.doSomething();
        }
    }
    ```
:::

[^1]: 依存対象が関数であればその型を宣言すれば十分ですし、Pythonなどダックタイピングが可能な言語では、抽象型を定義する必要はありません。重要なのは、上位モジュールが下位モジュールの詳細に依存しないことです。


:::message
#### DIのメリットとデメリット
メリット
- テスト容易性
- 結合度の低下
- DIPの実現
- グローバルオブジェクトを削除し、オブジェクトへの依存をコントロールできる（付録「DI」で説明）

デメリット
- DIコンテナなしではオブジェクトの初期化が複雑
:::


### DIとIoCとデザインパターン
IoCの実現方法としてDIがあります。意識することは少ないかもしれませんが、このパターンは身の回りのあらゆるところにあります。例えばフロントエンドの実装時、ボタンに対してonClick関数を定義することはよくありますが、ボタンが押されたらユーザーの処理を実行するという処理の制御は我々ではなく、あくまでのフレームワーク側もしくはブラウザ側が担ってくれており、これは制御の反転（IoC）だと言えます[^2]。フレームワーク側はボタンが押されたらonClick関数を呼び出すのでonClick関数に依存しており、それがcallback関数という形でフレームワーク側に注入されているという意味でDIによりIoCを実現していると言えます。他の例としては、多くのwebフレームワークにおいて、フレームワーク利用者は特定のURLに来たリクエストに対して行う処理を実装しますが、何らかの形でその処理をフレームワーク側に注入（DI）することで、その処理の呼出をフレームワーク側が自動で行ってくれます（IoC）。


[^2]: フレームワークとライブラリの違いは、IoCが実現されているかどうかにあると思うので、循環論法的な説明になっています...

またストラテジーパターンもDIにより実現していると言えます。GoFのストラテジーパターンは、交換可能なアルゴリズムの詳細クラスを主な処理のフローを担うクラスのメンバーとしてもたせることで実現しますが、この詳細クラスは基本的に外部から注入されるためDIを使っていると言えます。アルゴリズムの詳細実装をクラスに制限しなければ、上記のonClick関数の例も、onClickされたときのアルゴリズムを交換可能にしているという意味でストラテジーパターンになります。このようにストラテジーパターンはIoCの実現方法にもなりえます。DIを使うデザインパターンは他にも多数存在します。

フレームワークを実装するというのはIoCを実現することであり、そのためにDIは自ずと使われるもので、その実はストラテジーパターンになっているということが多いのではないかなと思います。

DIを使わずにIoCを実現する方法としては、テンプレートメソッドパターンなどの継承を使った方法も考えられますが、オブジェクト間の結合度が高くなるため、基本的にはDIを使うのが良いのかなと思います。


### デリゲートと合成とデザインパターンとDI

:::message
#### デリゲートとは
デリゲート（委譲）はいくつかの意味が混在して使われますが、本記事では「あるオブジェクト（Wrapper）のメンバーから、そのオブジェクトのメンバーである別オブジェクト（Wrappee）の対応するメンバーが呼ばれる」という意味でデリゲートという単語を使用します。正確には「デリゲート」はWrappeeのメンバーの評価がWrapper側で行われる場合のことを指しており、本記事で使用する「デリゲート」では、Wrappeeのメンバーの評価がWrappee側で行われるため、正確には「**フォワーディング（転送）**」と呼ばれます[^3]。フォワーディングに関しては「（付録）フォワーディング」で追記します。


[^3]: 英語版のwikipediaには[forwarding](https://en.wikipedia.org/wiki/Forwarding_(object-oriented_programming))のページがあり、デリゲートとの違いが述べられています。日本語版では[委譲](https://ja.wikipedia.org/wiki/%E5%A7%94%E8%AD%B2)のページでフォワーディングが（誤って？）説明されています。




フォワーディングはクラスに限った話ではなく、例えばあるメソッドが内部で別のメソッドを呼んでいてもフォワーディングと呼びます[^4]。継承して子クラスのメソッドから親クラスのメソッドを呼ぶ場合でもフォワーディングの定義は満たしています。
:::


デリゲートは合成の必要条件です。合成は合成されたクラスのメンバーを使うことが目的なので、合成をするなら基本的にデリゲートをしていることになります。ただし、デリゲートは「クラスのメソッドからそのクラスのメンバーである別クラスの対応するメソッドを呼ぶこと」というオブジェクト指向の文脈で使われることが多く、この文脈では合成はデリゲートの前提となっています。

![](/images/di-dip-ioc-design-patterns/delegate.png =350x)

[^4]: wikipediaの[forwarding](https://en.wikipedia.org/wiki/Forwarding_(object-oriented_programming))のページには、フォワーディングとデリゲートを説明するために、クラスではなくメソッドにおける例が紹介されています。


合成によるデリゲートを使ったデザインパターンは色々あります。特にデコレーターパターン、プロキシパターン、Chain of ResponsibilityパターンではWrapperとWrappeeは同じインターフェースを実装しておりメンバーは1:1対応しているため、これはフォワーディングを使ったデザインパターンと言えます。

### DIPとOCPとデザインパターン
GoFのデザインパターンは、本の題名に「オブジェクト指向における再利用のための」と入っているように、オブジェクトの再利用が目的の一つです。複数のオブジェクトを使った処理を行う際、そこには依存するオブジェクトと依存されるオブジェクトが存在します。依存されるオブジェクトを再利用したいときは、単純に他のオブジェクトからも同様にそのオブジェクトを呼び出すことで再利用が可能ですが、依存する側（呼び出し側）の処理を再利用したいこともあります。

例えば、音楽ファイルを再生するプログラムを書く際、大まかな再生処理の流れは同じで、ファイル読み込みの処理だけ.wavや.mp3などの種類に応じて変更する必要があったとします。この時、共通の再生処理はやはり再利用したいですが、単純に実装すると再生処理の一環としてファイル読み込みを行うので、再生処理はファイル読み込み処理に依存します。複数のファイル形式を再生できるようにするためには、単純には再生処理側でswitch文などで呼び出すファイル読み込み処理の分岐を行えば実現できます。しかし、例えば新しい音楽ファイル形式をサポートしたいとなった時は、再生処理側のswitch文を新しい形式に対応できるように変更しないといけません。しかし、メインの処理である再生処理のコードをファイル形式の追加に伴って変更するのはバグのもとであり避けるべきことです。つまり、依存する側（呼び出し側）のコードの変更なしに機能拡張を行うべきです。これはまさにOCPが言っていることです。今の問題は再生処理がファイル読み込み処理に直接依存していることが原因でした。このような問題を解決するのがDIPです。つまり、依存する側である上位のモジュールが依存される側である下位のモジュールに直接依存するのを避け、お互いが抽象に依存することで、オブジェクト同士が疎結合になり再利用性も高まります。今回の例では、再生処理（上位モジュール）はファイル読み込み処理（下位モジュール）を抽象化したインターフェースなどに依存することで、ファイル読み込み処理の詳細が隠蔽されて分岐処理は不必要になり、拡張に対するコードの変更もなくせます。

まとめると、デザインパターンが目指すオブジェクトの再利用において、再利用したい箇所が上位モジュールで変更や拡張の可能性のある箇所が下位モジュールである場合に、DIPを満たした実装を行うことでOCPを満たした再利用性の高い設計が可能になります。

DIPを満たしてるデザインパターンもストラテジーパターン、オブザーバーパターン、ビルダーパターンなど色々あります。OCPに関しては、基本的にすべてのデザインパターンがOCPを満たしています。

:::message
#### テンプレートメソッドパターンはDIPを満たしているか？
テンプレートメソッドパターンは、交換可能にしたいアルゴリズムのメソッドを上位モジュールでアブストラクトメソッドとして定義しておき、そのメソッドを上位モジュールを継承した下位モジュール側で行えば、上位モジュールも下位モジュールも抽象化されたメソッドに依存しておりDIPを実現していると言えそうです。しかし、テンプレートメソッドパターンは下位モジュールが上位モジュールを継承しており、そこには強力な具象への依存が発生いるため、DIPを満たしているとは言えません。
:::

# まとめ
設計周りでよくでてくる単語・デザインパターンの関係をまとめてみました。こういったパターンは繰り返し使われる実装方法を抽象化・言語化しただけなので、そのものは難しくないですが、概念を理解していることで設計の手助けになることもあるのかなと思います。


# （付録） DI
DIは本記事でも述べたとおり、DIPやIoCの手段として用いられます。さらにはテスト容易性の向上や結合度の低下にも寄与します。このあたりは[wikipedia](https://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E6%80%A7%E3%81%AE%E6%B3%A8%E5%85%A5)にも書いているとおりなのですが、t_wadaさんがゲスト回のfukabori.fmで、グローバルオブジェクトの問題を解決するためのDIという話があり、面白かったので紹介です。また簡単なDIコンテナの実装の話もあり勉強になりました。
https://fukabori.fm/episode/48




# （付録）フォワーディング
デリゲートは、記事によっては、子クラスから親クラスのメンバーを呼ぶことのできる継承と対比されて、フォワーディングの意味で「Wrapperクラスから合成されたWrappeeクラスのメンバーを呼ぶこと」という説明がなされますが、これは正確にはフォワーディングでありません。フォワーディングの定義は「Wrapperのメンバーに**対応する**Wrappeeのメンバーを呼ぶこと」です。


実際、英語版のwikipediaにおける[forwarding](https://en.wikipedia.org/wiki/Forwarding_(object-oriented_programming))の定義は、
>forwarding means that using a member of an object (略) results in actually using the **corresponding** member of a different object

> （訳）ファワーディングは、あるオブジェクトのメンバーを呼ぶと、別オブジェクトの**対応する**メンバーが呼ばれることである

となっています。「対応する」が意味するのは、「同じ責務を持つ」ということです。別の言い方をすると、WrapperとWrappeeが同じインターフェースを実装しているということになります。wikipediaにフォワーディングの例として挙げられてるデザインパターンもデコレーターパターン、プロキシパターン、Chain of ResponsibilityパターンなどのWrapperとWrappeeが同じインターフェースを実装しているものになります。このようにフォワーディングでは、WrapperとWrappeeに同じ責務を持った対応するメンバーがあることが前提となります。したがって、単純に合成されたオブジェクトのメンバーを呼ぶケース、例えばストラテジーパターンなどは、フォワーディングとは呼ばないので注意が必要です。
