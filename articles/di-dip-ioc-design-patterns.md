---
title: "DIとDIPとIoCとデザインパターンと"
emoji: "🌏"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["設計", "デザインパターン", "DI", "DIP", "IoC", "ストラテジーパターン", "デリゲート"]
published: false
---

# 概要
本記事では、設計やデザインパターンを勉強していると出てくる以下の単語たちの関連性をまとめます。

- 依存性の注入 (Dependency Injection: DI)
- 依存性逆転の法則 (Dependency Inversion Principle: DIP)
- 制御の逆転 (Inversion of Control: IoC)
- ストラテジーパターン
- デリゲートパターン（委譲）

各単語の意味はこの記事では既知とさせていただきます。また、デリゲートパターンはGoFのデザインパターンには載っていませんし、デザインパターンといっていいのかは怪しいですが、今回は一緒に扱います。

## DIとDIP
DIPを実現させる方法の一つとしてDIがあります。上位モジュールでコンストラクターの引数の型をinterfaceやabstract classなどの抽象型として定義し、その抽象型にしたがって実装された下位モジュールをコンストラクターに渡してあげれば、それはDIによりDIPを実現したということになります。

ただし、DIPの実現方法はDIだけではありません。DIPは「上位モジュールが下位モジュールに直接依存するな」と言っているだけなので、例えばテンプレートメソッドパターンのように[^1]継承を用いることでも実現可能です。上位モジュールは使用したい下位モジュールのメソッドをアブストラクトメソッドとして定義しておき、それらのメソッドは上位モジュールを継承した下位モジュール側で行えば、上位モジュールも下位モジュールも抽象に依存しておりDIPを実現していると言えます。一方で、DIによるDIPの実現は上位モジュールと下位モジュールの結合度を大きく下げてくれますが、テンプレートメソッドパターンでは継承を用いるため、上位モジュールと下位モジュールの結合度は容易に高くなる可能性があり、推奨される方法ではありません。


[^1]: ここでテンプレートメソッドパターンのようにと書いたのは、テンプレートメソッドパターンはあくまでもアルゴリズムの交換を容易にすることを目的としたパターンであり、DIPのためのパターンではないからです。しかしアブストラクトメソッドを継承先に実装させて、親クラスでそれを使うという構造は同じです。


## DIとIoCとストラテジーパターン
IoCの実現方法としてDIがあります。この方式は得に意識しませんがあらゆるところにあると思います。例えばフロントエンドを書くときに、ボタンに対してonClick関数を実装することはよくありますが、ボタンが押されたらユーザーの処理を実行するという処理の制御は我々ではなく、あくまでのフレームワーク側もしくはブラウザ側が担ってくれており、これは制御の反転（IoC）だと言えます[^2]。フレームワーク側はボタンが押されたらonClick関数を呼び出すのでonClick関数に依存しており、それがcallback関数という形でフレームワーク側に注入されているという意味でDIによりIoCを実現していると言えます。他には多くのwebフレームワークにおいて、フレームワーク利用者は特定のURLに来たリクエストに対して行う処理を実装しますが、何らかの形でその処理をフレームワーク側に注入（DI）することで、その処理の呼出をフレームワーク側が自動で行ってくれます（IoC）。


[^2]: フレームワークとライブラリの違いは、IoCが実現されているかどうかにあると思うので、循環論法的な説明になっています...

またストラテジーパターンもDIにより実現していると言えます。GoFのストラテジーパターンは、主な処理のフローを担うクラスAにアルゴリズムの詳細をもつ別クラスBをメンバーとしてもたせることで実現しますが、この詳細クラスBも基本的に外部から注入されるという点でDIを使っていると言えます。このアルゴリズムの詳細の実体をクラスに制限しなければ、上記のonClick関数の例も広い意味でストラテジーパターンになります。DIとストラテジーパターンの関係は、別の言い方をすると、DIを使った色々なパターンの一種としてストラテジーパターンがあるとも言えます。そしてストラテジーパターンはIoCの実現方法にもなりえます。

フレームワークを実装するというのはIoCを実現することであり、そのためにDIは自ずと使われるもので、その実はストラテジーパターンになっているということが多いのではないかなと思います。





## デリゲート（フォワーディング）とストラテジーパターン
この記事で取り上げるデリゲートは以下の記事におけるフォワーディング（転送）です[^3]。
https://qiita.com/jesus_isao/items/4b6b7846ccf5eb46b1bc

[^3]: 上記記事で三種類紹介されている「デリゲート」において、wikipediaでは転送の意味で[委譲](https://ja.wikipedia.org/wiki/%E5%A7%94%E8%AD%B2)として紹介されている。英語版には[forwarding](https://en.wikipedia.org/wiki/Forwarding_(object-oriented_programming))のページがあり、delegationとの違いが述べられている。

Swiftのdelegateは構造上はGoFのデザインパターンにおけるストラテジーパターンと全く同じ。
具体的には、あるインターフェースを実装したクラスAを主な処理の流れをもつクラスBのプロパティとして持たせ、クラスBはインターフェースに従ってクラスAのメソッドを呼び出すことで、クラスBの処理を実行するという点では両者は全く同じと言える。

しかしストラテジーパターンの目的はあくまでもメインのアルゴリズムを交換可能にすることだった。処理の流れは同じだがその各処理の実装が異なるようなときに用いるのがストラテジーパターン。

Swiftで使われるデリゲートはどちらかというとIoCの実現の手段のように思える。この意味でSwiftのデリゲートはDIにより近いと思われる。DIはDIPを実現するために使われたり、テスト容易性を上げたり、どういう文脈で出現したものかはわからないが、wikipediaにも

>制御の反転は依存性の注入と密接に関連している。依存性の注入は制御の反転を実現する有効な手法の一つである。

という一文がある。

さらにswiftのでリゲートは通知の手段としても用いられる。オブザーバーとの違い

デコレーターパターンとコンポジットパターン，デリゲートの違い

# まとめ
こういうパターンや名前は知らなくてもコーディングできますが、名前をつけることでその抽象的な概念を理解し、応用することにつながるのかなと思います。


# （付録） DI
DIは本記事でも述べたとおり、DIPやIoCの手段として用いられます。さらにはテスト容易性の向上や結合度の低下にも寄与します。このあたりは[wikipedia](https://ja.wikipedia.org/wiki/%E4%BE%9D%E5%AD%98%E6%80%A7%E3%81%AE%E6%B3%A8%E5%85%A5)にも書いているとおりなのですが、t_wadaさんがゲスト回のfukabori.fmで、グローバルオブジェクトの問題を解決するためのDIという話があり、面白かったので紹介です。
https://fukabori.fm/episode/48